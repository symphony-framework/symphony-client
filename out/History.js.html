<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: History.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: History.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as Y from 'yjs';

//yjs
/** @ignore */
class DeleteSet {
  constructor () {
    this.clients = new Map();
  }
}

//yjs
/** @ignore */
const sortAndMergeDeleteSet = ds => {
  ds.clients.forEach(dels => {
    let i, j
    for (i = 1, j = 1; i &lt; dels.length; i++) {
      const left = dels[j - 1]
      const right = dels[i]
      if (left.clock + left.len >= right.clock) {
        left.len = Math.max(left.len, right.clock + right.len - left.clock)
      } else {
        if (j &lt; i) {
          dels[j] = right
        }
        j++
      }
    }
    dels.length = j
  })
}

//yjs
/** @ignore */
const mergeDeleteSets = dss => {
  const merged = new DeleteSet()
  for (let dssI = 0; dssI &lt; dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        let dels = delsLeft.slice()
        for (let i = dssI + 1; i &lt; dss.length; i++) {
          dels = dels.concat(dss[i].clients.get(client) || [])
        }
        merged.clients.set(client, dels)
      }
    })
  }
  sortAndMergeDeleteSet(merged)
  return merged
}

/**
 * @hideconstructor
 */

class History {
  #undoManager;
  #pausedIndex;

  // Optionally, you may specify trackedOrigins to filter specific changes. By default, all local changes will be tracked. 
  constructor(syncedType, captureTimeout=0) {
    this.#undoManager = new Y.UndoManager(syncedType, {captureTimeout});
    this.#pausedIndex = null;
  }

  #merge() {
    const stack = this.#undoManager.undoStack;
    const deletionsToMerge = stack.slice(this.#pausedIndex).map(op => op.deletions);
    const insertionsToMerge = stack.slice(this.#pausedIndex).map(op => op.insertions);
    const lastOp = stack[stack.length - 1];
    lastOp.deletions = mergeDeleteSets(deletionsToMerge);
    lastOp.insertions = mergeDeleteSets(insertionsToMerge);
    // remove ops to be merged from stack
    stack.splice(this.#pausedIndex, this.#undoManager.undoStack.length - this.#pausedIndex);
    // add merged ops to stack
    stack.push(lastOp);
    this.#pausedIndex = null;
  }

  /**  Undoes the last operation by the client.*/
  undo() {
    if (this.#pausedIndex != null &amp;&amp; this.#pausedIndex &lt; this.#undoManager.undoStack.length) {
      this.#merge();
    }
    this.#undoManager.undo();
  }

  /** Redoes the last operation by the client.*/
  redo() {
    this.#undoManager.redo();
  }

  /** Checks whether there are any operations to undo, and returns a boolean.*/
  canUndo() {
    return this.#undoManager.undoStack.length > 0;
  }

  /** Checks whether there are any operations to redo, and returns a boolean.*/
  canRedo() {
    return this.#undoManager.redoStack.length > 0;
  }

  // https://discuss.yjs.dev/t/captureall-method-for-undomanager/959

  /** Merges all subsequent operations into a single operation until &lt;tt>stopMergingAll&lt;/tt> is called.*/
  mergeAll() {
    this.#pausedIndex = this.#undoManager.undoStack.length;
  }

  /** Stops merging operations; subsequent operations will be treated as separate.*/
  stopMergingAll() {
    if (this.#pausedIndex === null || this.#undoManager.undoStack.length &lt; 2) return;
    this.#merge();
  }

  /** Prevents the next operation from being merged with the previous based on &lt;tt>captureTimeout&lt;/tt>.*/
  stopCaptureTimeout() {
    this.#undoManager.stopCapturing();
  }

  /** Removes all operations from the history.*/
  clear() {
    this.#undoManager.clear();
  }

//   undoManager.on('stack-item-added', {stackItem: { meta: Map&lt;any,any>, type: 'undo'|'redo'}}
//     Register an event that is called when a StackItem is added to the undo- or the redo-stack.
//   undoManager.on('stack-item-popped', { stackItem: { meta: Map&lt;any,any> }, type: 'undo' | 'redo' })
//     Register an event that is called when a StackItem is popped from the undo- or the redo-stack.
}

export default History;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="History.html">History</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Mar 14 2023 19:04:25 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
